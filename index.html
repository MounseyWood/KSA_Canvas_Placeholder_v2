<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Layered Variable-Width Grid with Jostle & Hover Expansion</title>
  <!-- p5.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
  <script>
    // Global base settings:
    let globalScale = 1;       // Adjusted with mouse wheel
    let basePadding = 10;      // Horizontal padding for each text cell
    let baseVPadding = 6;      // Vertical padding
    let noiseScale = 0.03;     // For blocky color selection
    let t = 0;                 // Time variable for noise animation

    // Day mode (0) or Night mode (1)
    let mode = 0;

    // CSV words will be loaded from words.csv (which must be in the same folder)
    let wordTable;
    let words = [];

    // Preload CSV file
    function preload() {
      wordTable = loadTable('words.csv', 'csv', 'header');
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      textAlign(LEFT, TOP);
      noStroke();
      // Load words from CSV
      for (let i = 0; i < wordTable.getRowCount(); i++) {
        words.push(wordTable.getString(i, 'word'));
      }
    }

    function draw() {
      // Draw plain background (so gaps between cells show through)
      if (mode === 0) {
        background(255);  // Day: white background
      } else {
        background(0);    // Night: black background
      }
      
      // --- Layout cells into rows with default (multiplier = 1) ---
      // We compute a "default layout" for each cell (its baseline position)
      let marginX = 10, marginY = 10;
      let rows = []; // Each row will be an object: { cells: [], y: number, height: number }
      let currentRow = [];
      let xPos = marginX;
      let yPos = marginY;
      let rowHeight = 0;
      
      // For each word in order:
      for (let i = 0; i < words.length; i++) {
        // Measure text dimensions at base size (textSize(12) is our reference)
        let txt = words[i];
        let baseW = textWidth(txt) + basePadding;
        let baseH = textAscent() + textDescent() + baseVPadding;
        // Effective width using default multiplier = 1 and globalScale:
        let effW = baseW * globalScale;
        let effH = baseH * globalScale;
        
        // If adding this cell exceeds canvas width, finish the current row:
        if (xPos + effW > width - marginX) {
          rows.push({ cells: currentRow, y: yPos, height: rowHeight });
          currentRow = [];
          yPos += rowHeight + marginY;
          xPos = marginX;
          rowHeight = 0;
        }
        
        // Save baseline properties for this cell
        currentRow.push({
          word: txt,
          baseW: baseW,
          baseH: baseH,
          // Default baseline x (for hover detection later)
          defaultX: xPos,
          // These will be computed later after multiplier assignment:
          x: 0, y: 0, effW: 0, effH: 0,
          multiplier: 1  // default multiplier
        });
        xPos += effW;
        if (effH > rowHeight) rowHeight = effH;
      }
      // Push any remaining row:
      if (currentRow.length > 0) {
        rows.push({ cells: currentRow, y: yPos, height: rowHeight });
      }
      
      // --- For each row, update multipliers if the mouse is over that row ---
      for (let r = 0; r < rows.length; r++) {
        let row = rows[r];
        // Check if mouseY falls within this row's vertical range:
        if (mouseY >= row.y && mouseY <= row.y + row.height) {
          // Determine hovered cell in this row based on default layout:
          let hoverIndex = -1;
          for (let i = 0; i < row.cells.length; i++) {
            let cell = row.cells[i];
            let effW = cell.baseW * globalScale;  // default effective width
            if (mouseX >= cell.defaultX && mouseX <= cell.defaultX + effW) {
              hoverIndex = i;
              break;
            }
          }
          // Assign multipliers for cells in this row:
          if (hoverIndex >= 0) {
            for (let i = 0; i < row.cells.length; i++) {
              let d = abs(i - hoverIndex);
              if (d === 0) row.cells[i].multiplier = 3.0;
              else if (d === 1) row.cells[i].multiplier = 2.0;
              else if (d === 2) row.cells[i].multiplier = 1.5;
              else if (d === 3) row.cells[i].multiplier = 1.25;
              else row.cells[i].multiplier = 1.0;
            }
          }
        } else {
          // For rows not hovered, keep multiplier = 1.
          for (let cell of row.cells) {
            cell.multiplier = 1.0;
          }
        }
        
        // --- Re-layout this row using the updated multipliers ---
        let xPosRow = marginX;
        let maxH = 0;
        for (let i = 0; i < row.cells.length; i++) {
          let cell = row.cells[i];
          let effW = cell.baseW * globalScale * cell.multiplier;
          let effH = cell.baseH * globalScale * cell.multiplier;
          cell.x = xPosRow;
          // Vertically center the cell in the row (using the row's original height)
          cell.y = row.y + (row.height - effH) / 2;
          cell.effW = effW;
          cell.effH = effH;
          xPosRow += effW;  // push next cell to the right edge
          if (effH > maxH) maxH = effH;
        }
        row.height = maxH;
      }
      
      // --- Draw each row's cells using a layered approach ---
      // For each row, we draw the cells sorted by multiplier (lowest drawn first).
      for (let r = 0; r < rows.length; r++) {
        let row = rows[r];
        // Create a sorted copy of the row's cells:
        let sortedCells = row.cells.slice().sort((a, b) => a.multiplier - b.multiplier);
        for (let i = 0; i < sortedCells.length; i++) {
          let cell = sortedCells[i];
          push();
          // Apply a slight jostle to each cell using Perlin noise:
          let jostleX = map(noise(cell.x * 0.01, row.y * 0.01, t), 0, 1, -5, 5);
          let jostleY = map(noise(cell.x * 0.01 + 100, row.y * 0.01 + 100, t), 0, 1, -5, 5);
          translate(cell.x + jostleX, cell.y + jostleY);
          
          // Choose a blocky color scheme for the cell using noise:
          let n = noise(cell.x * noiseScale + 555, cell.y * noiseScale + 555, t);
          if (mode === 0) {
            // Day mode:
            // n < 0.33 => black background, yellow text (#ffed00)
            // n < 0.66 => yellow background, black text
            // else     => white background, black text
            if (n < 0.33) {
              fill(0);
              rect(0, 0, cell.effW, cell.effH);
              fill('#ffed00');
            } else if (n < 0.66) {
              fill('#ffed00');
              rect(0, 0, cell.effW, cell.effH);
              fill(0);
            } else {
              fill(255);
              rect(0, 0, cell.effW, cell.effH);
              fill(0);
            }
          } else {
            // Night mode:
            // n < 0.33 => white background, blue text (rgb(0,146,212))
            // n < 0.66 => blue background, white text
            // else     => black background, white text
            if (n < 0.33) {
              fill(255);
              rect(0, 0, cell.effW, cell.effH);
              fill(0,146,212);
            } else if (n < 0.66) {
              fill(0,146,212);
              rect(0, 0, cell.effW, cell.effH);
              fill(255);
            } else {
              fill(0);
              rect(0, 0, cell.effW, cell.effH);
              fill(255);
            }
          }
          
          // If this cell is the hovered one (multiplier 3), draw text bold
          if (cell.multiplier >= 3) textStyle(BOLD);
          else textStyle(NORMAL);
          
          textSize(12 * globalScale);
          text(cell.word, 5, 3);
          pop();
        }
      }
      
      t += 0.01;  // animate noise over time
    }
    
    // Toggle day/night mode on mouse click
    function mousePressed() {
      mode = (mode + 1) % 2;
    }
    
    // Zoom in/out using the mouse wheel (adjusts globalScale)
    function mouseWheel(event) {
      globalScale = constrain(globalScale - event.delta * 0.001, 0.5, 5);
      return false;
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
