<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Jostling Grid with CSV Words & Hover Expansion</title>
  <!-- p5.js library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
  <script>
    // Global parameters for the grid cells (base dimensions)
    let cellW = 80;
    let cellH = 18;
    let noiseScale = 0.03;
    let t = 0;  // time variable for noise animation

    // Day (0) or Night (1)
    let mode = 0;

    // CSV words will be loaded here
    let wordTable;
    let words = [];

    // Preload the CSV file (must be in same folder and have a header "word")
    function preload() {
      wordTable = loadTable('words.csv', 'csv', 'header');
    }

    function setup() {
      createCanvas(windowWidth, windowHeight);
      textAlign(LEFT, TOP);
      textSize(12);
      
      // Load words from CSV
      for (let i = 0; i < wordTable.getRowCount(); i++) {
        words.push(wordTable.getString(i, 'word'));
      }
    }

    function draw() {
      // Draw plain background behind cells:
      // Day mode: white; Night mode: black.
      if (mode === 0) {
        background(255);
      } else {
        background(0);
      }
      
      // Determine which grid cell is hovered.
      // We assume a grid with fixed cellW and cellH.
      let hoverCol = floor(mouseX / cellW);
      let hoverRow = floor(mouseY / cellH);
      
      let wordIndex = 0;
      
      // Loop over the grid cells
      for (let y = 0; y < height; y += cellH) {
        let row = floor(y / cellH);
        for (let x = 0; x < width; x += cellW) {
          let col = floor(x / cellW);
          
          // Compute jostle offsets (as in your inspiration code)
          let offsetX = map(noise(x * noiseScale, y * noiseScale, t), 0, 1, -cellW/2, cellW/2);
          let offsetY = map(noise(x * noiseScale + 999, y * noiseScale + 999, t), 0, 1, -cellH/2, cellH/2);
          let finalX = x + offsetX;
          let finalY = y + offsetY;
          
          // Determine grid distance from hovered cell (using Chebyshev distance)
          let d = max(abs(col - hoverCol), abs(row - hoverRow));
          let localMult = 1.0;
          if (d === 0) {
            localMult = 3.0;
          } else if (d === 1) {
            localMult = 2.0;
          } else if (d === 2) {
            localMult = 1.5;
          } else if (d === 3) {
            localMult = 1.25;
          }
          
          // Use noise to pick a blocky color pattern (offset noise as in inspiration)
          let n = noise(x * noiseScale + 555, y * noiseScale + 555, t);
          
          push();
          // Translate to the cell’s jostled position and then apply the local (hover) scaling.
          translate(finalX, finalY);
          scale(localMult);
          
          // Draw the cell’s background rectangle.
          if (mode === 0) {
            // Day mode:
            // n < 0.33 => black bg, yellow text (#ffed00)
            // n < 0.66 => yellow bg, black text
            // else     => white bg, black text
            if (n < 0.33) {
              fill(0);
              rect(0, 0, cellW, cellH);
              fill('#ffed00');
            } else if (n < 0.66) {
              fill('#ffed00');
              rect(0, 0, cellW, cellH);
              fill(0);
            } else {
              fill(255);
              rect(0, 0, cellW, cellH);
              fill(0);
            }
          } else {
            // Night mode:
            // n < 0.33 => white bg, blue text (rgb(0,146,212))
            // n < 0.66 => blue bg, white text
            // else     => black bg, white text
            if (n < 0.33) {
              fill(255);
              rect(0, 0, cellW, cellH);
              fill(0,146,212);
            } else if (n < 0.66) {
              fill(0,146,212);
              rect(0, 0, cellW, cellH);
              fill(255);
            } else {
              fill(0);
              rect(0, 0, cellW, cellH);
              fill(255);
            }
          }
          
          // For the hovered cell, use bold text.
          if (d === 0) {
            textStyle(BOLD);
          } else {
            textStyle(NORMAL);
          }
          textSize(12); // fixed text size (can be adjusted)
          // Draw the word (cycle through the words array)
          text(words[wordIndex], 2, 2);
          pop();
          
          wordIndex = (wordIndex + 1) % words.length;
        }
      }
      
      t += 0.01;  // animate noise
    }

    // Toggle day/night mode on mouse click
    function mousePressed() {
      mode = (mode + 1) % 2;
    }
    
    // Adjust cell size (zoom) using the mouse wheel.
    function mouseWheel(event) {
      // Adjust cellW and cellH proportionally.
      cellW = constrain(cellW - event.delta * 0.001 * 80, 40, 160);
      cellH = constrain(cellH - event.delta * 0.001 * 18, 9, 36);
      return false; // prevent default scrolling
    }
    
    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>
